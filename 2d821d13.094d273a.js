(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{148:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return s}));var a=n(2),o=n(9),r=(n(0),n(200)),i={id:"manipulate",title:"Start here",sidebar_label:"Start here"},l={id:"tutorials/manipulate",title:"Start here",description:"PopGen.jl includes basic commands to provide obvious methods to inspect and alter PopData. Using standard Julia conventions, only commands ending with a bang ! are mutable, meaning they alter the input data. So, commands like populations will show you population information, whereas populations! will change that information in your PopData. The mutable commands here alter the data in your PopData, but not the source data (i.e. the files used to create the PopData). Read over Accessing parts of PopData to become familiar with the components of PopData.",source:"@site/docs/tutorials/manipulate.md",permalink:"/PopGen.jl/docs/tutorials/manipulate",editUrl:"https://github.com/pdimens/popgen.jl/edit/documentation/docs/tutorials/manipulate.md",lastUpdatedAt:1590785696,sidebar_label:"Start here",sidebar:"docs",previous:{title:"Variant Call Format",permalink:"/PopGen.jl/docs/io/vcf"},next:{title:"Accessing elements",permalink:"/PopGen.jl/docs/tutorials/accessing"}},c=[{value:"Accessing Elements",id:"accessing-elements",children:[]},{value:"Viewing and Sorting",id:"viewing-and-sorting",children:[]},{value:"Sample and Locus Exclusion/Removal",id:"sample-and-locus-exclusionremoval",children:[]},{value:"Location and Population Information",id:"location-and-population-information",children:[]}],p={rightToc:c};function s(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"PopGen.jl includes basic commands to provide obvious methods to inspect and alter ",Object(r.b)("inlineCode",{parentName:"p"},"PopData"),". Using standard Julia conventions, only commands ending with a bang ",Object(r.b)("inlineCode",{parentName:"p"},"!")," are mutable, meaning they alter the input data. So, commands like ",Object(r.b)("inlineCode",{parentName:"p"},"populations")," will show you population information, whereas ",Object(r.b)("inlineCode",{parentName:"p"},"populations!")," will change that information in your ",Object(r.b)("inlineCode",{parentName:"p"},"PopData"),". The mutable commands here alter the data in your ",Object(r.b)("inlineCode",{parentName:"p"},"PopData"),", but not the source data (i.e. the files used to create the ",Object(r.b)("inlineCode",{parentName:"p"},"PopData"),"). Read over ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"accessing"}),"Accessing parts of PopData")," to become familiar with the components of ",Object(r.b)("inlineCode",{parentName:"p"},"PopData"),". "),Object(r.b)("p",null,'The "manipulation" commands were separated into three sections to make it less overwhelming, and using the ',Object(r.b)("inlineCode",{parentName:"p"},"gulfsharks")," data, you can explore each of the sections like a little tutorial. The sections don't follow any particular order, so feel free to jump around however you like. "),Object(r.b)("p",null,"To follow along like a tutorial, load the ",Object(r.b)("inlineCode",{parentName:"p"},"gulfsharks")," data in if you haven't already:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-julia"}),"julia> using PopGen\n\njulia> sharks = gulfsharks() ;\n")),Object(r.b)("h3",{id:"accessing-elements"},Object(r.b)("a",Object(a.a)({parentName:"h3"},{href:"accessing"}),"Accessing Elements")),Object(r.b)("h3",{id:"viewing-and-sorting"},Object(r.b)("a",Object(a.a)({parentName:"h3"},{href:"viewsort"}),"Viewing and Sorting")),Object(r.b)("h3",{id:"sample-and-locus-exclusionremoval"},Object(r.b)("a",Object(a.a)({parentName:"h3"},{href:"exclusion"}),"Sample and Locus Exclusion/Removal")),Object(r.b)("h3",{id:"location-and-population-information"},Object(r.b)("a",Object(a.a)({parentName:"h3"},{href:"populations"}),"Location and Population Information")))}s.isMDXComponent=!0},200:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return b}));var a=n(0),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=o.a.createContext({}),s=function(e){var t=o.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=s(e.components);return o.a.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},m=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=s(n),m=a,b=u["".concat(i,".").concat(m)]||u[m]||d[m]||r;return n?o.a.createElement(b,l(l({ref:t},p),{},{components:n})):o.a.createElement(b,l({ref:t},p))}));function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=m;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var p=2;p<r;p++)i[p]=n[p];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);